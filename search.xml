<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Meanshift 聚类算法</title>
      <link href="/2020/07/23/Algorithm/meanshift/"/>
      <url>/2020/07/23/Algorithm/meanshift/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>聚类分析，又称群分析，指对样本数据的一种划分与归类的一种方法。聚类算法以相似性为基础，将样本数据中按照相似度不同分成不同的族群（类别）中。同一族群中，样本相似性相差小；不同族群中，样本相似性差异较大。</p><p>Meanshift，又称均值漂移算法，是一种基于核密度的估计算法，将每个族群的中心点移动到该族群的密度最大的位置，来对样本进行分类。</p><p>相较于其他分类算法，Meanshift 不需要指定分类的族群数量，而是根据样本特性自动生成不同类别的族群。其广泛应用于聚类、图像平滑、分割、跟踪等方面。</p><p>本文以聚类为例，探讨 Meanshift 的原理及实现。</p><a id="more"></a><h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>假设在给定的 d 维空间中 N 个样本数据点集 X，那么对于空间中的任意点 $x$ 的 mean shift 向量的基本形式可以表示为：</p><script type="math/tex; mode=display">M = \frac{1}{K} \sum_{x_i \in S_k} (x_i - x)</script><p>其中， $S_k$ 为数据集中的点 $x_i$ 到点 $x$ 的距离小于 d 维球半径的 r 的数据点，既：</p><script type="math/tex; mode=display">S_h(x) = \{ y:(y - x_i)^T(y - x_i) < h^2 \}</script><p>而漂移的过程，就是不断计算漂移向量，然后更新球心位置，更新公式为：</p><script type="math/tex; mode=display">x_{n+1} = x_n + M_n</script><h2 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h2><p>我们以二维平面上的点为例（d = 2）：</p><p><img src="/2020/07/23/Algorithm/meanshift/d_2_sample_1.png" style="zoom:50%;"></p><p>如上图所示，平面上散布着 200 个点，以半径 r = 0.3 进行更新漂移量 $M$ 的值，其过程如下：</p><p><img src="/2020/07/23/Algorithm/meanshift/d_2_sample_1.gif" style="zoom:50%;"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 聚类算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 聚类算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程珠玑-向量旋转</title>
      <link href="/2020/06/21/Programming%20Pearls/%E5%90%91%E9%87%8F%E6%97%8B%E8%BD%AC/"/>
      <url>/2020/06/21/Programming%20Pearls/%E5%90%91%E9%87%8F%E6%97%8B%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>假设我们有这么一个问题：</p><p>我们有一个 n 维的向量（数组），现在我们需要将前面的 r 个元素移动到末尾，如下所示：</p><p><img src="/2020/06/21/Programming%20Pearls/%E5%90%91%E9%87%8F%E6%97%8B%E8%BD%AC/向量旋转示例1.png" style="zoom:100%;"></p><p>我们该如何操作呢？</p><a id="more"></a><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>如果对操作方法不加任何限制，我们可以将这个向量当作数组来进行操作</p><blockquote><p>1、定义一个额外的数组，保存前 r 个数据；</p><p>2、将剩下的 n - r 个数据从第 r + 1 位向前平移 r 位；</p><p>3、将额外数组中的数据复制到 原数组的后 r 位中。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">7</span></span><br><span class="line">r = <span class="number">3</span></span><br><span class="line">samples = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line">tmpsample = [<span class="string">''</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,r)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, r):</span><br><span class="line">    tmpsample[i] = samples[i]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(r, n):</span><br><span class="line">    samples[i - r] = samples[i]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - r, n):</span><br><span class="line">    samples[i] = tmpsample[i - (n - r)]</span><br></pre></td></tr></table></figure><p>我们来分析一下上面方法的消耗：</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="number">7</span></span><br><span class="line">r = <span class="number">3</span></span><br><span class="line">samples = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'g'</span>]</span><br><span class="line">tmpsample = [<span class="string">''</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,r)]           <span class="comment">#开辟了一个大小为 r 的数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, r): <span class="comment">#r 次赋值操作</span></span><br><span class="line">    tmpsample[i] = samples[i]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(r, n):<span class="comment">#n - r 次赋值操作</span></span><br><span class="line">    samples[i - r] = samples[i]</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n - r, n):<span class="comment">#r 次赋值操作</span></span><br><span class="line">    samples[i] = tmpsample[i - (n - r)]</span><br></pre></td></tr></table></figure><p>1、大小为 r 的额外空间</p><p>2、n + r 次赋值操作（忽略循环本身内部消耗）</p></blockquote><p>看起来似乎很简单，但是我们要注意一点，采用这种方法的时候，我们额外开辟了一个大小为 r 的数组，在上面的例子中，r = 3 ，可能我们觉得这个开销并不算什么，但是当我们的数据达到一定数量时（比如 n = 100000000， r = 99999999），这个额外的空间开销以及时间消耗就十分巨大了。而我们可能并没有足够的内存空间以及时间来让我们使用。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>看起来第一个方法足够简单清晰，但是性能似乎并不是那么好。那么，还有其他的方法吗？</p><p>让我们思考一下，对向量的旋转在操作的本质上就是对数据的平移，之所以消耗了大量的空间以及时间，就在于我们在将后面的数据平移到前面的数据时，需要临时保存前面的数据。</p><p>但是，我们同样可以发现，在我们平移最后的 r 位数据时，后面的这些空间似乎被浪费掉了。那么，我们能否将最后面的这 r 个空间利用起来呢？</p><p>让我们将整个数组想象成一个圆环，然后从最后面的一位向前平移 r 位，被替换的数字同样向前平移 r 位，直到到达数组中的前 r 位数据，这时，我们将这一位数据放到最后面的 r 位中：</p>]]></content>
      
      
      <categories>
          
          <category> 编程珠玑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程珠玑 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客部署到VPS</title>
      <link href="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/"/>
      <url>/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Hexo 博客搭建完成后，可以将博客部署到 git 服务商提供的静态网页服务上，如 Github，Gitee等。当然，如果有自己的 VPS 服务器的话，还可以将博客部署到 VPS 服务器上，通过 IP 或者有域名来进行访问。</p><p>本文记录将 Hexo 部署到 VPS 的步骤，以供参阅。</p><a id="more"></a><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>VPS端</p><blockquote><p>CentOS 7.6 64位</p><p>Git</p><p>宝塔控制面板</p><p>Nginx</p></blockquote><p>本地</p><blockquote><p>Git</p><p>Hexo</p></blockquote><p>本地 Hexo 博客已经搭建好了，再次不做赘述。详细步骤可以参考我之前的文章。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当使用 hexo g 命令生成博客内容时，Hexo 实际上是将我们编写的 md 文件编译成 html 文件，存放在 Hexo 根目录下的 public 文件夹中。而我们使用 hexo d 命令后，Hexo 会把 public 文件夹中的内容通过 git 上传到 git 服务器上，服务器将 public 中的内容部署到博客站点上，我们就可以通过 git 服务器提供的站点网址访问我们的博客内容。</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/principle.png" style="zoom:80%;"></p><p>因此，我们要想在 vps 上部署我们的博客，要做的内容其实就很清楚了：</p><blockquote><p>1、在 vps 上创建 git 服务器；</p><p>2、在 vps 上创建网站；</p><p>3、通过 hero d 命令上传本地博客内容；</p><p>4、vps 自动将上传的内容部署到站点内；</p><p>5、通过域名或站点网址访问博客。</p></blockquote><h2 id="在-vps-服务器上创建-Git-服务器"><a href="#在-vps-服务器上创建-Git-服务器" class="headerlink" title="在 vps 服务器上创建 Git 服务器"></a>在 vps 服务器上创建 Git 服务器</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>首先，我们需要购买一台 安装有 Linux 系统的 VPS 服务器，本文使用的 Linux 系统是 CentOS 64 位。</p><p>我们通过 ssh 登录到我们的服务器：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root<span class="meta">&amp;yourip</span></span><br></pre></td></tr></table></figure><p>按照提示输入密码后：</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/sshlogin.png" alt="sshlogin" style="zoom:50%;"></p><p>出现如下界面表示登录成功。</p><p>现在，让我们来看一下 git 是否安装，输入命令</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="comment">--version</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/cheak_git_1.png" style="zoom:50%;"></p><p>如提示未找到命令，说明我们的系统中尚未安装 git，因此我们需要先在系统中安装 git：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> git</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/install_git.png" style="zoom:50%;"></p><p>出现以上界面说明 git 正在安装。</p><p>安装过程中可能会出现询问是否确认安装的界面：</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/confim_install.png" style="zoom:50%;"></p><p>按照提示，确认安装即可。</p><p>安装完成后检查一下是否安装成功：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="comment">--version</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/cheak_git_2.png" style="zoom:50%;"></p><p>出现 git 的版本，说明安装成功。</p><h3 id="创建-git-服务器"><a href="#创建-git-服务器" class="headerlink" title="创建 git 服务器"></a>创建 git 服务器</h3><p>首先，我们需要在系统中创建一个名为 git 的用户组和用户来运行 git 服务：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">groupadd git            <span class="comment">//创建 git 用户组</span></span><br><span class="line">useradd git -g git      <span class="comment">//创建 git 用户</span></span><br><span class="line">passwd git              <span class="comment">//设置 git 用户密码</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/xudapeng/Blog/source/_posts/Hexo/Hexo博客部署到VPS/add_git_user.png" style="zoom:50%;"></p><p>创建完成后，我们需要给 git 用户添加账户权限，用户权限需要通过编辑 /ect/sudoers 进行设置。</p><p>通过命令打开 /ect/sudoers 文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">740</span> <span class="regexp">/etc/</span>sudoers</span><br><span class="line">vim <span class="regexp">/etc/</span>sudoers</span><br></pre></td></tr></table></figure><p>找到：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## Allow root <span class="keyword">to</span> run <span class="keyword">any</span> commands anywhere</span><br><span class="line">root    <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)       <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/access_git_1.png" style="zoom:50%;"></p><p>按 i 进入 vim 的编辑模式，添加一行：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git     <span class="keyword">ALL</span>=(<span class="keyword">ALL</span>)       <span class="keyword">ALL</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/access_git_2.png" style="zoom:50%;"></p><p>按 ESC 键退出编辑模式，输入 :wq 回车退出，并将 /etc/sudoers 改回权限：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod <span class="number">400</span> /etc/sudoers</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/access_git_3.png" style="zoom:50%;"></p><p>现在，通过</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">su git</span></span><br></pre></td></tr></table></figure><p>命令切换至 git 用户：</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/su_git_1.png" style="zoom:50%;"></p><p>通过 cd 命令，进入到 /home/git/ 路径下，并输入 pwd 命令查看当前路径以确认是否正确进入到该路径下：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/home/git</span></span><br><span class="line"><span class="keyword">pwd</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/home_git_1.png" style="zoom:50%;"></p><p>接下来，首先，我们先关闭这个 ssh 连接，然后通过 ssh 将本地计算机的 ssh 公钥上传到服务器上（中间需要输入一次 git 用户的密码）:</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-<span class="keyword">copy</span>-<span class="built_in">id</span> git@yourip</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/xudapeng/Blog/source/_posts/Hexo/Hexo博客部署到VPS/ssh_copy_id.png" alt></p><p>接下来，重新登录到 vps ，切换至 git 用户，进入到 /home/git/.ssh 目录下赋予 authorized_keys 文件及 .ssh 目录相应的权限：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 authorzied_keys </span><br><span class="line"><span class="keyword">cd</span> <span class="string">..</span></span><br><span class="line">chmod 700 <span class="string">.ssh</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/chmode_ssh.png" style="zoom:50%;"></p><p>再次退出登录，使用 ssh 通过</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssh</span> git<span class="variable">@yourip</span></span><br></pre></td></tr></table></figure><p>免密码登录到 vps 上。</p><p>在 git 目录下，创建 blog.git 目录：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> blog.git</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/mkdir_blog.git.png" style="zoom:50%;"></p><p>通过 cd 命令进入到 blog.git 目录下，并输入</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment">--bare</span></span><br></pre></td></tr></table></figure><p>创建裸 git 仓库：</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/git_init.png" style="zoom:50%;"></p><p>输入</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /<span class="built_in">home</span>/git/blog.git</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/xudapeng/Blog/source/_posts/Hexo/Hexo博客部署到VPS/cheak_access_git_blog.git.png" style="zoom:50%;"></p><p>若上图中红色标注的位置是 git 说明 git 用户对 /home/blog 目录有操作权限，若显示的是 root 则需要</p><p>通过</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown <span class="string">git:</span>git -R <span class="regexp">/home/</span>git/blog.git</span><br></pre></td></tr></table></figure><p>命令对 /home/git/blog.git 目录权限进行更改。</p><p>通过 sudo 命令在 /var 检查有没有 www 目录，若没有，则创建 www 目录。</p><p>在 www 目录下创建 blog 目录</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">var</span></span><br><span class="line"><span class="keyword">cd</span> www</span><br><span class="line">sudo <span class="keyword">mkdir</span> www</span><br><span class="line">sudo <span class="keyword">mkdir</span> blog</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/mkdir_www_blog.png" style="zoom:50%;"></p><p>确保 </p><blockquote><p>/home/git/blog.git</p><p>/home/git/.ssh</p><p>/var/www/blog</p></blockquote><p>三个目录的用户权限组都是 git :</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ll <span class="meta-keyword">/home/</span>git/blog.git</span><br><span class="line">ll <span class="meta-keyword">/home/</span>git/.ssh</span><br><span class="line">ll <span class="meta-keyword">/var/</span>www</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/ll_three_1.png" style="zoom:50%;"></p><p>可以看到，/var/www 目录的权限是 root ，通过以下命令对其权限进行修改：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown g<span class="symbol">it:gi</span><span class="built_in">t</span> -R /<span class="built_in">var</span>/www/blog</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/sudo_chown_var_www_blog.png" style="zoom:50%;"></p><h2 id="自动部署上传内容"><a href="#自动部署上传内容" class="headerlink" title="自动部署上传内容"></a>自动部署上传内容</h2><p>这里，我们使用 Git Hooks来进行博客内容的自动部署。</p><blockquote><p>Git Hooks</p><p>Git Hooks 可以理解为 Git 在特定事件发生之前或之后执行的脚本。</p><p>通过编写 Git Hooks 脚本，我们来实现 Git 服务器对本地计算机 hexo 博客上传后的自动部署功能。 </p></blockquote><p>打开 /home/git/blog.git 目录：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/home/git/blog.git</span></span><br><span class="line"><span class="keyword">ls</span></span><br><span class="line"><span class="keyword">cd</span> hooks</span><br><span class="line"><span class="keyword">ls</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/blog.git_hooks.png" style="zoom:50%;"></p><p>通过 vim 创建 post-receive 文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vi post-receive</span></span><br></pre></td></tr></table></figure><p>将一下子内容复制到 post-receive 文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">GIT_REPO=/home/git/blog.git</span><br><span class="line">TMP_GIT_CLONE=/tmp/blog</span><br><span class="line">PUBLIC_WWW=/var/www/blog</span><br><span class="line">rm -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</span><br><span class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span></span><br></pre></td></tr></table></figure><p>保存退出后，执行</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x post-<span class="keyword">receive</span></span><br></pre></td></tr></table></figure><p>命令赋予可执行权限。</p><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><h4 id="安装-gcc"><a href="#安装-gcc" class="headerlink" title="安装 gcc"></a>安装 gcc</h4><p>首先查看系统中是否已经安装了 gcc :</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gcc -v</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/gcc_v.png" style="zoom:100%;"></p><p>如上所示表明系统中已经安装了 gcc，无需再次安装。如果提示未找到命令，说明系统中没有安装 gcc ，可以通过以下命令安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> gcc</span><br></pre></td></tr></table></figure><h4 id="安装-pcre、pcre-devel"><a href="#安装-pcre、pcre-devel" class="headerlink" title="安装 pcre、pcre-devel"></a>安装 pcre、pcre-devel</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> -y pcre pcre-devel</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/yun_install_pcre.png" style="zoom:100%;"></p><h4 id="安装-zlib"><a href="#安装-zlib" class="headerlink" title="安装 zlib"></a>安装 zlib</h4><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y <span class="literal">zlib</span> <span class="literal">zlib</span>-devel</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/yum_install_zlib.png" style="zoom:100%;"></p><h4 id="安装openssl"><a href="#安装openssl" class="headerlink" title="安装openssl"></a>安装openssl</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> -y openssl openssl-devel</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/yum_install_openssl.png" style="zoom:50%;"></p><h3 id="安装-Nginx-1"><a href="#安装-Nginx-1" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><h4 id="下载-Nginx-安装包"><a href="#下载-Nginx-安装包" class="headerlink" title="下载 Nginx 安装包"></a>下载 Nginx 安装包</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="regexp">//</span>nginx.org<span class="regexp">/download/</span>nginx-<span class="number">1.9</span>.<span class="number">9</span>.tar.gz</span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/wget_nginx.png" style="zoom:100%;"></p><p>将文件移动到 /tmp 目录下</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv nginx<span class="number">-1.9</span><span class="number">.9</span>.tar.gz /tmp</span><br></pre></td></tr></table></figure><p>进入到 /tmp 目录，解压文件</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/tar_nginx.png" style="zoom:50%;"></p><p>查看 /tmp 目录下内容</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/cd_nginx.png" style="zoom:100%;"></p><p>进入到 nginx-1.9.9 目录下。</p><h4 id="安装-Nginx-2"><a href="#安装-Nginx-2" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h4><p>在 nginx-1.9.9 目录下执行下面三个命令：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line"><span class="built_in">make</span></span><br><span class="line"><span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><h4 id="配置-Nginx"><a href="#配置-Nginx" class="headerlink" title="配置 Nginx"></a>配置 Nginx</h4><p>切换到 /usr/local/nginx 目录下：</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/cd_local_nginx.png" style="zoom:100%;"></p><p>进入到 nginx/config 目录下：</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/cd_nginx_config.png" style="zoom:100%;"></p><p>编辑 nginx.conf 文件，将以下内容填入 nginx.conf 中：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span> nginx.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> git git;</span><br><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>;                                     <span class="comment">#设置值和CPU核心数一致</span></span><br><span class="line"><span class="attribute">error_log</span> /usr/local/nginx/logs/nginx_error.log <span class="literal">crit</span>;   <span class="comment">#日志位置和日志级别</span></span><br><span class="line"><span class="comment">#Specifies the value for maximum file descriptors that can be opened by this process.</span></span><br><span class="line"><span class="attribute">worker_rlimit_nofile</span> <span class="number">65535</span>;</span><br><span class="line">events</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">use</span> <span class="literal">epoll</span>;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">65535</span>;</span><br><span class="line">&#125;</span><br><span class="line">http</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">include</span> mime.types;</span><br><span class="line">    <span class="attribute">default_type</span> application/octet-stream;</span><br><span class="line">    <span class="attribute">log_format</span> main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">               <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">               <span class="string">'"<span class="variable">$http_user_agent</span>" <span class="variable">$http_x_forwarded_for</span>'</span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">#charset gb2312;</span></span><br><span class="line">     </span><br><span class="line">    <span class="attribute">server_names_hash_bucket_size</span> <span class="number">128</span>;</span><br><span class="line">    <span class="attribute">client_header_buffer_size</span> <span class="number">32k</span>;</span><br><span class="line">    <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">32k</span>;</span><br><span class="line">    <span class="attribute">client_max_body_size</span> <span class="number">8m</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="attribute">sendfile</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span> <span class="number">60</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">128k</span>;</span><br><span class="line">    <span class="attribute">gzip</span> <span class="literal">on</span>; </span><br><span class="line">    <span class="attribute">gzip_min_length</span> <span class="number">1k</span>;</span><br><span class="line">    <span class="attribute">gzip_buffers</span> <span class="number">4</span> <span class="number">16k</span>;</span><br><span class="line">    <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br><span class="line">    <span class="attribute">gzip_types</span> text/plain application/x-javascript text/css application/xml;</span><br><span class="line">    <span class="attribute">gzip_vary</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#下面是server虚拟主机的配置</span></span><br><span class="line">    server</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;                                              <span class="comment">#监听端口</span></span><br><span class="line">        <span class="attribute">server_name</span> exmaple.com www.example.com yourip;         <span class="comment">#域名</span></span><br><span class="line">        <span class="attribute">root</span> /var/www/blog;                                     <span class="comment">#站点目录</span></span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(php|php5)?$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="comment">#fastcgi_pass unix:/tmp/php-cgi.sock;</span></span><br><span class="line">            <span class="attribute">fastcgi_pass</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="attribute">fastcgi_index</span> index.php;</span><br><span class="line">            <span class="attribute">include</span> fastcgi.conf;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|png|bmp|swf|ico)$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">30d</span>;</span><br><span class="line">            <span class="comment">#access_log off;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">location</span> <span class="regexp">~ .*\.(js|css)?$</span></span><br><span class="line"><span class="regexp"></span>        &#123;</span><br><span class="line">            <span class="attribute">expires</span> <span class="number">15d</span>;</span><br><span class="line">            <span class="comment">#access_log off;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动 neginx</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/nginx/</span>sbin<span class="regexp">/nginx</span></span><br></pre></td></tr></table></figure><p>其他命令</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/nginx/</span>sbin/nginx             <span class="meta">#启动 </span></span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/nginx/</span>sbin/nginx -s stop     <span class="meta">#快速关闭（不建议使用）</span></span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/nginx/</span>sbin/nginx -s quit     <span class="meta">#等待完成用户请求后关闭（建议使用）</span></span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/nginx/</span>sbin/nginx -t          <span class="meta">#检查配置文件内容</span></span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/nginx/</span>sbin/nginx -s reload   <span class="meta">#重启 nginx</span></span><br><span class="line"><span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/nginx/</span>sbin/nginx -c filename <span class="meta">#以制定配置文件启动</span></span><br></pre></td></tr></table></figure><p>强行停止 nginx</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | <span class="keyword">grep</span> nginx   <span class="comment">#查看 nginx 所有进程</span></span><br><span class="line">pkill -<span class="number">9</span> nginx        <span class="comment">#关闭所有 nginx 进程</span></span><br></pre></td></tr></table></figure><h4 id="设置开机启动"><a href="#设置开机启动" class="headerlink" title="设置开机启动"></a>设置开机启动</h4><p>通过源码安装的 nginx 想要设置开机启动，需要手动在 /usr/lib/systemd/system/ 目录下创建 nginx.service 文件。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="class"><span class="keyword">lib</span>/<span class="title">systemd</span>/<span class="title">system</span>/<span class="title">nginx</span>.<span class="title">service</span></span></span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=nginx</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line">  </span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=forking</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/nginx/sbin/nginx</span><br><span class="line"><span class="attr">ExecReload</span>=/usr/local/nginx/sbin/nginx -s reload</span><br><span class="line"><span class="attr">ExecStop</span>=/usr/local/nginx/sbin/nginx -s quit</span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">true</span></span><br><span class="line">  </span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>如果现在 nginx 处于运行状态，首先要先关闭 nginx。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> nginx.service  <span class="comment">#设置开机自启</span></span><br><span class="line">systemctl status nginx.service  <span class="comment">#查看 nginx 状态</span></span><br></pre></td></tr></table></figure><p>如果查看 nginx 运行状态显示结果如下：</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/nginx_service_statu.png" style="zoom:100%;"></p><p>那么需要先杀死所有nginx 进程：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pkill -9 nginx                  <span class="comment">#关闭所有 nginx 进程</span></span><br><span class="line">systemctl <span class="keyword">start</span> nginx           <span class="comment">#启动 nginx</span></span><br><span class="line">systemctl <span class="keyword">status</span> nginx.service  <span class="comment">#查看 nginx 状态</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/start_nginx_service.png" style="zoom:100%;"></p><p>重启服务器</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">reboot</span></span><br></pre></td></tr></table></figure><p>等待重启完成后，重新连接服务器，查看 nginx 运行状态：</p><p><img src="/2020/06/16/Hexo/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/reboot_nginx_status.png" style="zoom:100%;"></p><h3 id="上传博客内容"><a href="#上传博客内容" class="headerlink" title="上传博客内容"></a>上传博客内容</h3><p>进入到本机的 Hexo 博客根目录下，打开 _config.yml 文件，在</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  </span><br><span class="line">  #在此添加vps上的仓库地址</span><br><span class="line">  <span class="attribute">repository</span>: </span><br><span class="line">    <span class="attribute">self</span>: git<span class="variable">@www</span>.example.<span class="attribute">com</span>:/home/git/blog.git </span><br><span class="line">    #或者 <span class="attribute">self</span>: git<span class="variable">@vpsip</span>:/home/git/blog.git</span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure><p>保存后在此目录下打开终端，输入命令：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hexo</span> <span class="string">clean</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">g</span></span><br><span class="line"><span class="attr">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><p>等待上传完成后，在浏览器中输入你的域名或者是 vps 的 ip （需要在 nginx.conf 中声明），就能看到博客的主页了！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程珠玑-磁盘文件排序</title>
      <link href="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>假设现在有一个包含有 5000000（500万）个整数型的数据列表，其中的数据范围为 0 — 9999999，并且无重复数据。现在，我们想对这个列表进行排序，该如何去做呢？</p><a id="more"></a><p>答案似乎很简单，无论是最简单的冒泡排序，选择排序到稍微复杂点的快速排序、归并排序，甚至许多编程语言都内置了相关的排序算法，都能简单的解决这个问题。</p><p>那么，如果再加上一点限定条件呢？比如说这些数据存在于磁盘中的一个文件中，我们需要将这个文件内的数据排序后输出到另一个文件中，又该怎么做呢？</p><p>我们知道，一个 int 型的数据在绝大多数编程语言中占 4 个字节，即 4B ，那么500万个整型数据就是2千万个字节，大概是 19M，即这个文件的大小大概在 19M 左右。</p><p>无论上述的各种排序算法性能如何，都有一个共同的特点：所有的操作都是在内存中完成的。也就是说，我们如果想使用以上所述的排序算法，所做的第一件事便是读取文件，将文件中的所有数据读入到一个内存中，然后再通过以上算法进行排序运算，最后输出到一个文件中。</p><p>听起来似乎很简单，我们要做的无非是三步：</p><blockquote><p>1、读取文件，将数据存入一个500万大小的数组中；</p><p>2、对这个数组进行排序；</p><p>3、将排序后的数组中的数据输出到一个文件中。</p></blockquote><p>本文肯定不会讨论如此简单的问题。那么，让我们再做点有难度的事情。</p><p>上面我们计算过，500万个整型数据，需要开辟一个500万大小的整型数组，大概需要 19M 的内存。那么，我们再加一点限定条件：整个系统只有 2M 内存可供使用，也就是说，我们所能使用的内存不能超过 2M。</p><p>事情似乎变得有趣起来，我们该如何使用 2M 的内存，来读取大概 19M 的数据，然后对其进行排序呢？</p><p>上面我们所说的几种排序算法似乎面对这种情况有些无能为力，那么我们就要思考其他的方法了。</p><p>首先我么考虑下， 2M 内存有多大，能够做些什么？</p><p>2M 内存，能够存储 524288 个整型数据，即大概52万个数据。显然距离我们的500万个数据规模相差甚远。</p><p>既然一次读不完，那么我们是否能够分批对这个文件进行读取处理呢？</p><p>我们似乎看到了曙光。500万个数据，我们每次加入只读取50万个数据进行处理，那么只需要10次处理就行了，那还等什么，让我们开始动手吧！</p><h2 id="分批排序"><a href="#分批排序" class="headerlink" title="分批排序"></a>分批排序</h2><p>首先，我们先创建一个包含500万个不重复的 0 - 9999999 之间的整数列表，并将其写入到一个文本文件中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sampleList = random.sample(range(<span class="number">0</span>, <span class="number">9999999</span>), <span class="number">5000000</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./磁盘排序_sample.txt"</span>, <span class="string">"w"</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(sampleList)):</span><br><span class="line">        <span class="keyword">if</span> i &lt; len(sampleList) - <span class="number">1</span>:</span><br><span class="line">            file.writelines(str(sampleList[i]) + <span class="string">"\n"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            file.writelines(str(sampleList[i]))</span><br></pre></td></tr></table></figure><p>文本内容如下：</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/sampleList.png" alt="样本数据" style="zoom:50%;"></p><p>现在，让我们开始吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">batch = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">500000</span>)]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./磁盘排序_sample.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> read:</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> readLine <span class="keyword">in</span> read:</span><br><span class="line">        batch[index] = int(readLine)</span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index == len(batch):</span><br><span class="line">            <span class="keyword">with</span> open(<span class="string">"./磁盘排序_sorted.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> write:</span><br><span class="line">                batch.sort()</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(batch)):</span><br><span class="line">                    write.writelines(str(batch[i]) + <span class="string">"\n"</span>)</span><br><span class="line">            index = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>让我们打开排序后的文本文件看一下内容：</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f1_sorted_1_6.png" alt style="zoom:50%;"></p><p>似乎看起来成功了！</p><p>等一下，我们再详细看一下文本：</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f1_sorted_1_1000006.png" style="zoom:50%;"></p><p>情况似乎有些不对，让我们来分析下我们这个方法：</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f1_示意图.png" style="zoom:39%;"></p><p>通过示意图，我们可以看到：我们将样本数据分为 10 个 batch 来处理，对每个 batch 进行排序后输出到文件中去，我们只能保证的是，在样本数据的 10 个 batch 中的每个 batch 内部，数据是有序的，也就是说，batch1 中的数据是有序的，batch2 中的数据也是有序的，但是，batch1 和 batch2 内的数据是有序的吗？</p><p>并不是，因为我们的排序的数据只局限于每个 batch 中，batch 之间并没有进行过排序操作，因此无法保证分批处理后，得到的所有数据都是有序的。</p><p>这个方法失败了，似乎分批的想法行不通，那么该怎么办呢？</p><p>别急，我们换个角度思考。让我们再审一边问题：</p><blockquote><p>假设现在有一个包含有 5000000（500万）个整数型的数据列表，其中的数据范围为 0 — 9999999，并且无重复数据。现在，我们想对这个列表进行排序，并且使用的内存不能超过 2M，该如何去做呢？</p></blockquote><p>既然将数据分批的思路行不通，那么我们是否能够将样本数据的数据范围进行分批操作呢？</p><p>由问题可知，样本数据的范围是 0 — 9999999，即样本中的每个数据都是1000万内的数字，我们可以使用的内存是 2M ，大概能够记录 50 万个数据。现在，我们把 0—9999999 ，分成 0—499999，500000—999999 …… 9500000—9999999，共20组，我们每次只读取样本数据中的一组数值范围内的数据，并进行排序操作，然后写入文件中去，如下所示：</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f2示意图.png" alt></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">batchSize = <span class="number">500000</span></span><br><span class="line">batch = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, batchSize)]</span><br><span class="line">batchCount = int(<span class="number">10000000</span> / batchSize)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, batchCount):</span><br><span class="line">    low = i * batchSize</span><br><span class="line">    height = low + batchSize</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./磁盘排序_sample.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> read:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> read:</span><br><span class="line">            <span class="keyword">if</span> int(line) &gt;= low <span class="keyword">and</span> int(line) &lt; height:</span><br><span class="line">                batch[index] = int(line)</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./磁盘排序_sorted.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> write:</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> sorted(batch[<span class="number">0</span> : index]):</span><br><span class="line">            write.writelines(str(value) + <span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>看一下运算结果：</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f2_sorted.png" style="zoom:50%;"></p><p>可以看到，这个方法成功得在限定条件内完成了对样本数据的排序。</p><p>那么，我们看一下这个方法的运行消耗：</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f2_消耗示意图.png" style="zoom:39%;"></p><p>我们可以看到，500万个样本数据，总共读取了20次，相当于总共在磁盘中读取了20 x 500万，即1亿个数据。我们知道，电脑对磁盘的读写速度是远不如对内存读写的速度的。虽然我们成功将数据进行了排序，但是其运行速度十分缓慢，绝大部份时间都消耗在对磁盘数据的读写。</p><p>那么，还有没有更好的方法（更快的方法）完成对磁盘文件的读写呢？让我们继续往下看。</p><h2 id="位向量"><a href="#位向量" class="headerlink" title="位向量"></a>位向量</h2><p>我们设想一种方法，能够最少次数地读取样本文件，能够最少次数的写入结果文件，同时，其排序部分有尽量小的耗时。</p><p>我们再观察一遍问题：</p><blockquote><p>假设现在有一个包含有 5000000（500万）个整数型的数据列表，其中的数据范围为 0 — 9999999，并且无重复数据。现在，我们想对这个列表进行排序，并且使用的内存不能超过 2M，该如何去做呢？</p></blockquote><p>我们之前所关注的重点是：</p><blockquote><p>1、500万个整型数据；</p><p>2、数据分布范围为 0 —9999999；</p><p>3、内存不能超过 2M。</p></blockquote><p>我们似乎忽略了一个重要的点：</p><pre><code>&gt; 1、无重复数据</code></pre><p>这个要点能否帮助我们完成我们期待的算法呢？</p><p>我们来看一个简单的例子，假如我们有一组数据：</p><blockquote><p>0 ，9，4，7，3</p></blockquote><p>我们该如何将这组数据通过一种简单的方法进行排序呢？</p><p>假如我们有10个桶，每个桶只有两种状态：空和满，给这十个桶写上编号，分别是 0 ，1 ，2 …… 9:</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f3_1.png" alt="f3_1" style="zoom:39%;"></p><p>现在，10个桶都是空的，我们把这组数据按照其元素的值的大小，放入编号与值相同的桶中，如 9 放入编号为 9 的桶里，3 放入编号为 3 的桶里。</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f3_2.png" alt="f3_2" style="zoom:39%;"></p><p>现在，我们的10个桶里总共有5个桶是满的，我们只要从头遍历这10个桶，遇到满的桶就将其编号记录下来：</p><blockquote><p>0 ，3 ，4 ，7 ，9</p></blockquote><p>我们似乎已经得到了排序好的数据。那么，我们是否能用这个方法来解决我们最初的问题呢？</p><p>首先，我们来分析一下上面方法能够使用的条件：</p><blockquote><p>1、要有足够多的桶（桶的编号要能包含样本数据中所有元素的可能值）；</p><p>2、样本数据不重复；</p></blockquote><p>我们来看我们的题目是否满足以上两点要求：</p><blockquote><p>1、要有足够多的桶：</p><p>​    我们的样本数据范围是 0 — 9999999 ，那么我们就需要 1000万个桶，假如我们定义一个 int 型数组来当作桶，那么这个数组的大小应该是 int a[10000000]；很容易算出来，a 的大小应该是 10000000 x 4 / 1024 /1024 = 38.15M ，但是我们能够使用的内存只有 2M，不满足条件。</p><p>2、数据不重复：</p><p>​    由题目可知，我们的样本数据无重复数据，因此是满足条件的。</p></blockquote><p>似乎又陷入了僵局，还是内存大小不满足条件，那我们真的没有别的办法了吗？</p><p>等一下，我们知道，一个 int 型数据占 4 个字节，而一个字节是 8 个比特位，我们能否用一个比特位来当作一个桶呢？</p><p>稍微计算一下，1000万个桶就是1000万个比特位 = 1.2M，比问题中要求的要小，似乎是可行的！</p><p>我们来尝试一下（1000万比特位是 312500 个 int 型数组的大小）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bucketCount = <span class="number">312500</span></span><br><span class="line">buckets = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, bucketCount)]</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./磁盘排序_sample.txt"</span>, <span class="string">"r"</span>) <span class="keyword">as</span> read:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> read:</span><br><span class="line">        bucketIndex = int(int(line) / <span class="number">32</span>)</span><br><span class="line">        byteIndex = int(line) % <span class="number">32</span></span><br><span class="line">        buckets[bucketIndex] = buckets[bucketIndex] | (<span class="number">1</span> &lt;&lt; byteIndex)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./磁盘排序_sorted.txt"</span>, <span class="string">"a"</span>) <span class="keyword">as</span> write:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, bucketCount):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">32</span>):</span><br><span class="line">            <span class="keyword">if</span> buckets[i] &amp; (<span class="number">1</span> &lt;&lt; j) != <span class="number">0</span>:</span><br><span class="line">                write.writelines(str(i * <span class="number">32</span> + j) + <span class="string">"\n"</span>)</span><br></pre></td></tr></table></figure><p>查看运行结果：</p><p><img src="/2020/06/14/Programming%20Pearls/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91-%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F/f2_sorted.png" style="zoom:50%;"></p><p>成功！</p><h2 id="引申1"><a href="#引申1" class="headerlink" title="引申1"></a>引申1</h2><p>如果我们再加一个限定条件，所使用内存不能超过 1M，那我们这个算法还适用吗？</p><p>答案显而易见，我们想要使用这个算法，最少需要使用大概 1.2M 的内存空间，因此这个算法就不能适用了。那我们该怎么办呢？</p><p>会想下我们最开始的做法，我们只要将样本数据的数据范围 0—9999999 分为两批：</p><blockquote><p>0—4999999</p><p>5000000—9999999</p></blockquote><p>然后将这两种算法相结合，便能满足我们的需求。</p><h2 id="引申2"><a href="#引申2" class="headerlink" title="引申2"></a>引申2</h2><p>如果样本数据中的数据是可以重复的，但是每个数据的重复次数不超过10次，那么这个算法还能适用吗？</p><p>这种情况下，我们只需要将算法进行稍微的变动。我们原本的做法是将 1 个比特位当作一个桶，现在，我们将 4 个比特位当作一个桶，那么，一个桶的状态便有 16 种情况，即一个桶可以表示 0—15 的数据，我们只要将重复的数据塞到同一个桶里，同时，这个桶通过其本身的 4 比特位进行计数。读取完毕后，再反过来遍历桶，便能达到我们的目的。</p><p>如果将 4b 当作一个桶，我们需要的内存大概是 4.7M，超出了 2M 的内存大小，这事，我们便可以将样本数据的范围进行分批处理，同样能够满足问题的要求。</p>]]></content>
      
      
      <categories>
          
          <category> 编程珠玑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 编程珠玑 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K近邻算法进阶-手写数字识别</title>
      <link href="/2019/06/30/Machine%20Learning/machine-learning-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%89%8B%E5%86%99%E6%B1%89%E5%AD%97%E8%AF%86%E5%88%AB/"/>
      <url>/2019/06/30/Machine%20Learning/machine-learning-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E8%BF%9B%E9%98%B6-%E6%89%8B%E5%86%99%E6%B1%89%E5%AD%97%E8%AF%86%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>手写数字识别——机器学习领域的Hello World</p><p>本章将通过实现手写数字识别的程序，用以探讨K近邻算法的进阶使用。</p><a id="more"></a><h2 id="数据集介绍"><a href="#数据集介绍" class="headerlink" title="数据集介绍"></a>数据集介绍</h2><p>本章用以进行程序实现的数据集来源于《机器学习实战》一书的源码中的数据集。</p><p>该数据集包含于两个目录内：</p><blockquote><p>TrainingDigits</p><p>TestDigits</p></blockquote><p>我们使用的数据集中，所使用的样本并非是图片格式的数据，而是类似于将数字的灰度图片转换为 0，1 信息的文本文件。</p><p>数字 0 对应的样本数据内容如下：</p><blockquote><p>00000000000001100000000000000000<br>00000000000011111100000000000000<br>00000000000111111111000000000000<br>00000000011111111111000000000000<br>00000001111111111111100000000000<br>00000000111111100011110000000000<br>00000001111110000001110000000000<br>00000001111110000001110000000000<br>00000011111100000001110000000000<br>00000011111100000001111000000000<br>00000011111100000000011100000000<br>00000011111100000000011100000000<br>00000011111000000000001110000000<br>00000011111000000000001110000000<br>00000001111100000000000111000000<br>00000001111100000000000111000000<br>00000001111100000000000111000000<br>00000011111000000000000111000000<br>00000011111000000000000111000000<br>00000000111100000000000011100000<br>00000000111100000000000111100000<br>00000000111100000000000111100000<br>00000000111100000000001111100000<br>00000000011110000000000111110000<br>00000000011111000000001111100000<br>00000000011111000000011111100000<br>00000000011111000000111111000000<br>00000000011111100011111111000000<br>00000000000111111111111110000000<br>00000000000111111111111100000000<br>00000000000011111111110000000000<br>00000000000000111110000000000000</p></blockquote><p>可以看到，由 0 和 1组成的32 x 32的数字矩阵大概构成了一幅手写数字 0 的图片。</p><p>其中，TrainingDigits 目录下包含了数字 0-9 的32 x 32的txt文件形式（如下图）2000个例子。每个例子都是一个txt文件，</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K近邻算法</title>
      <link href="/2019/04/17/Machine%20Learning/machine-learning-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2019/04/17/Machine%20Learning/machine-learning-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>存在一个样本数据集合（训练样本集），并且每个样本都有确定的标签，即样本与标签之间存在一一对应的关系。输入没有标签的样本（测试样本），将测试样本的数据与训练样本集中的数据进行比较，然后提取训练样本集中与测试样本最相似（最近邻）的分类标签，选择提取标签中的前K个标签（可能会重复），在K个标签集中出现次数最多的标签，作为测试样本的分类。</p><a id="more"></a><h2 id="简单举例"><a href="#简单举例" class="headerlink" title="简单举例"></a>简单举例</h2><p>举个简单的例子，二维空间中存在两类样本（训练样本）A、B，那么当给出一个样本（测试样本）C时，我们怎样判断C是属于哪一类呢？</p><p><img src="/2019/04/17/Machine%20Learning/machine-learning-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/A_B_Set.png" width="70%" height="70%" alt="Set" align="center"></p><p>上图中，存在7个训练样本（A<sub>1</sub>，A<sub>2</sub>，A<sub>3</sub>，B<sub>1</sub>，B<sub>2</sub>，B<sub>3</sub>，B<sub>4</sub>），1个测试样本（C）。</p><p>训练样本共分为两类：</p><blockquote><p>A：A<sub>1</sub>，A<sub>2</sub>，A<sub>3</sub>；</p><p>B：B<sub>1</sub>，B<sub>2</sub>，B<sub>3</sub>，B<sub>4</sub>；</p></blockquote><p>当我们想要确定测试样本C的分类时，K近邻算法的思想是：</p><blockquote><p>1.计算训练样本集合中所有样本与C点的距离；</p><p>2.对训练样本集合中所有样本与C点的距离排序；</p><p>3.找出与C点距离最近的的前K个训练样本；</p><p>4.在第3步找出的前K个样本中出现最多的分类；</p><p>5.确定C的分类。</p></blockquote><p>我们按照K近邻算法来对C点进行分类：</p><p>1.计算训练样本集合中所有样本与C点的距离</p><blockquote><p>C —&gt; A<sub>1</sub>：1.41</p><p>C —&gt; A<sub>2</sub>：2.00</p><p>C —&gt; A<sub>3</sub>：1.00</p><p>C —&gt; B<sub>1</sub>：1.00</p><p>C —&gt; B<sub>2</sub>：3.00</p><p>C —&gt; B<sub>3</sub>：3.16</p><p>C —&gt; B<sub>4</sub>：2.24</p></blockquote><p>2.对训练样本集合中所有样本与C点的距离排序</p><blockquote><p>C —&gt; A<sub>3</sub>：1.00</p><p>C —&gt; B<sub>1</sub>：1.00</p><p>C —&gt; A<sub>1</sub>：1.41</p><p>C —&gt; A<sub>2</sub>：2.00</p><p>C —&gt; B<sub>4</sub>：2.24</p><p>C —&gt; B<sub>2</sub>：3.00</p><p>C —&gt; B<sub>3</sub>：3.16</p></blockquote><p>3.找出与C点距离最近的的前K个训练样本，我们取K=4</p><blockquote><p>C —&gt; A<sub>3</sub>：1.00</p><p>C —&gt; B<sub>1</sub>：1.00</p><p>C —&gt; A<sub>1</sub>：1.41</p><p>C —&gt; A<sub>2</sub>：2.00</p></blockquote><p>4.在第3步找出的前K个样本中出现最多的分类</p><blockquote><p>我们可以明显看出，按照距离排序吼的前K（K=4）个训练样本中，A类出现了3次，B类出现了1次，记作：</p><p>A：3</p><p>B：1</p></blockquote><p>5.确定C的分类</p><blockquote><p>由第四步得到的结果，我们将测试样本C归为A类。</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>接下来就按上例来用Python代码实现。</p><p>首先，导入所需的库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入numpy库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 导入operator库</span></span><br><span class="line"><span class="keyword">import</span> operator</span><br></pre></td></tr></table></figure><p>然后，创建训练样本数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建训练数据</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_train_data</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建训练样本集</span></span><br><span class="line">    group=np.array([</span><br><span class="line">        [<span class="number">1.00</span>,<span class="number">2.00</span>],</span><br><span class="line">        [<span class="number">2.00</span>,<span class="number">3.00</span>],</span><br><span class="line">        [<span class="number">2.00</span>,<span class="number">2.00</span>],</span><br><span class="line">        [<span class="number">3.00</span>,<span class="number">1.00</span>],</span><br><span class="line">        [<span class="number">5.00</span>,<span class="number">1.00</span>],</span><br><span class="line">        [<span class="number">5.00</span>,<span class="number">2.00</span>],</span><br><span class="line">        [<span class="number">4.00</span>,<span class="number">0.00</span>]])</span><br><span class="line">    <span class="comment"># 创建样本标签集</span></span><br><span class="line">    labels=[<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>,<span class="string">'B'</span>]</span><br><span class="line">    <span class="keyword">return</span> group,labels</span><br></pre></td></tr></table></figure><p>上述代码定义了一个函数 get_train_data ，用来创建我们想用来训练的7个样本数据集：group，以及每个样本相对应的标签数据集：labels。</p><p>每个样本包括两个数据：x 坐标和 y 坐标。标签数据集则包含每个样本的分类名称。样本与其标签存在着一一对应的关系，比如样本数据集中的第二个样本：[2.00,3.00]，便对应着标签数据集中的第二个标签  ’A‘ ，意味着样本 [2.00,3.00] 属于分类 A。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取样本数据集以及标签数据集</span></span><br><span class="line">group,labels=create_train_data()</span><br></pre></td></tr></table></figure><p>我们用两个变量 group ， labels 来保存我们创建样本数据集函数的返回值，即： group 保存样本数据集，labels 保存标签数据集。</p><p>现在，我们来创建我们的分类函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分类函数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">in_data:输入的测试点</span></span><br><span class="line"><span class="string">train_data:用于训练的样本数据集</span></span><br><span class="line"><span class="string">train_labels:用于训练的标签数据集</span></span><br><span class="line"><span class="string">k:截取相似样本个数</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify</span><span class="params">(in_data,train_data,train_labels,k)</span>:</span></span><br><span class="line">    <span class="comment"># 计算样本个数</span></span><br><span class="line">    train_data_size=train_data.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># （以下四行）计算距离</span></span><br><span class="line">    diff_mat=np.tile(in_data,(train_data_size,<span class="number">1</span>))-train_data</span><br><span class="line">    sq_diff_mat=diff_mat**<span class="number">2</span></span><br><span class="line">    sq_distances=sq_diff_mat.sum(axis=<span class="number">1</span>)</span><br><span class="line">    distances=sq_distances**<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取对距离进行降序排序后的索引</span></span><br><span class="line">    sorted_distance_indexes=distances.argsort()</span><br><span class="line">    <span class="comment"># 类别计数</span></span><br><span class="line">    class_count=&#123;&#125;</span><br><span class="line">    <span class="comment"># 从 distances 中选择距离最小的 k 个点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">        vote_lable=labels[sorted_distance_indexes[i]]</span><br><span class="line">        class_count[vote_lable]=class_count.get(vote_lable,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#将类别计数器按其类数个数排序</span></span><br><span class="line">    sorted_class_count=sorted(class_count.items(),key=operator.itemgetter(<span class="number">1</span>),reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 返回计数最多的类别</span></span><br><span class="line">    <span class="keyword">return</span> sorted_class_count[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>下面，我们来详细解释上述分类函数的欧式距离计算方式。</p><p>首先，函数共有4个参数：</p><blockquote><p>in_data:    输入的测试点<br>train_data:    用于训练的样本数据集<br>train_labels:    用于训练的标签数据集<br>k:    截取相似样本个数</p></blockquote><p>我们假设用创建训练样本数据集函数得到的样本数据：</p><blockquote><p>group,labels=create_train_data()</p></blockquote><p>来进行分类，用 测试样本</p><blockquote><p>C=[2.00,1.00]</p></blockquote><p>来用作测试数据。取 K=4 ，则函数所得到的参数如下：</p><blockquote><p>in_data=[2.00,1.00]</p><p>train_data=[[1. 2.]<br>[2. 3.]<br>[2. 2.]<br>[3. 1.]<br>[5. 1.]<br>[5. 2.]<br>[4. 0.]]</p><p>train_labels=[‘A’, ‘A’, ‘A’, ‘B’, ‘B’, ‘B’, ‘B’]</p><p>k=4</p></blockquote><p>我们先计算训练样本的个数，将其保存在变量 train_data_size 中，此时：</p><blockquote><p>train_data_size=7</p></blockquote><p>我们再看：</p><blockquote><p>diff_mat=np.tile(in_data,(train_data_size,1))-train_data</p></blockquote><p>我们知道， in_data 是一个一行两列的矩阵，in_data=[2.00,1.00]，虽然我们可以用 for 循环的方式，来计算每个训练样本与测试样本的欧式距离，但 for 循环的效率相当低下，因此我们采用效率更高的计算方法：矩阵操作。</p><p>首先使用 np.tile() 函数将 测试样本in_data 扩展为与测试样本相同大小的矩阵（7行2列）</p><blockquote><script type="math/tex; mode=display">np.tile(in\_data,(tra\_data\_size,1))=\left[ \begin{matrix} 2.00&1.00\\ 2.00&1.00\\ 2.00&1.00\\ 2.00&1.00\\2.00&1.00\\2.00&1.00\\2.00&1.00\\\end{matrix} \right]</script></blockquote><p>再用得到的矩阵与训练样本矩阵作减法运算，结果保存在 diff_mat 矩阵中，具体过程如下：</p><blockquote><script type="math/tex; mode=display">diff\_mat=\left[ \begin{matrix} 2.00&1.00\\ 2.00&1.00\\ 2.00&1.00\\ 2.00&1.00\\2.00&1.00\\2.00&1.00\\2.00&1.00\\\end{matrix} \right]-\left[ \begin{matrix} 1.00&2.00\\ 2.00&3.00\\ 2.00&2.00\\ 3.00&1.00\\5.00&1.00\\5.00&2.00\\4.00&0.00\\\end{matrix} \right]=\left[ \begin{matrix} 1.00&-1.00\\ 0.00&-1.00\\ 0.00&-2.00\\ -1.00&0.00\\-3.00&0.00\\-3.00&-1.00\\-2.00&1.00\\\end{matrix} \right]</script></blockquote><p>得到 diff_mat 矩阵后，计算欧式距离：</p><blockquote><p>sq_diff_mat=diff_mat**2</p><script type="math/tex; mode=display">sq\_diff\_mat=\left[ \begin{matrix} 1.00&-1.00\\ 0.00&-1.00\\ 0.00&-2.00\\ -1.00&0.00\\-3.00&0.00\\-3.00&-1.00\\-2.00&1.00\\\end{matrix} \right]^2=\left[ \begin{matrix} 1.00&1.00\\ 0.00&1.00\\ 0.00&4.00\\ 1.00&0.00\\9.00&0.00\\9.00&1.00\\4.00&1.00\\\end{matrix} \right]</script><p>当然，此处的平方操作并不是严格意义上的矩阵（乘法）运算，而是矩阵内各元素求平方。</p></blockquote><p>接下来，我们将 sq_diff_mat 矩阵按行求和得到 sq_distances 矩阵：</p><blockquote><p>sq_distances=sq_diff_mat.sum(axis=1)</p><script type="math/tex; mode=display">sq\_distances=sum(\left[ \begin{matrix} 1.00&1.00\\ 0.00&1.00\\ 0.00&4.00\\ 1.00&0.00\\9.00&0.00\\9.00&1.00\\4.00&1.00\\\end{matrix} \right])=\left[ \begin{matrix} 2.00\\ 1.00\\ 4.00\\ 1.00\\9.00\\10.00\\5.00\\\end{matrix} \right]</script></blockquote><p>然后，再对 sq_distances 矩阵按行开平方得到 distances 矩阵：</p><blockquote><script type="math/tex; mode=display">distances=\left[ \begin{matrix} 2.00\\ 1.00\\ 4.00\\ 1.00\\9.00\\10.00\\5.00\\\end{matrix} \right]^{0.5}=\left[ \begin{matrix} 1.41\\ 1.00\\ 2.00\\ 1.00\\3.00\\3.16\\2.24\\\end{matrix} \right]</script></blockquote><p>接下来，将所得到的距离矩阵 distances 按升序排序后的索引保存在 sorted_distance_indexes 中：</p><blockquote><p>sorted_distance_indexes=distances.argsort()</p></blockquote><p>结果如下：</p><blockquote><p>sorted_distance_indexes=[2 3 0 1 6 4 5]</p></blockquote><p>定义一个类别计数器：</p><blockquote><p>class_count={}</p></blockquote><p>用 for 循环来记录测试样本与训练样本的最小的前 K 个样本的类别出现的次数：</p><blockquote><p>for i in range(k):<br>&emsp; vote_lable=labels[sorted_distance_indexes[i]]<br>&emsp; class_count[vote_lable]=class_count.get(vote_lable,0)+1</p></blockquote><p>得到的结果如下：</p><blockquote><p>class_count={‘A’: 3, ‘B’: 1}</p></blockquote><p>最后，将 class_cont 按值排序后，返回出现次数最高的分类（A），作为对 C 的分类。</p><p>调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试样本</span></span><br><span class="line">C=[<span class="number">2.00</span>,<span class="number">1.00</span>]</span><br><span class="line"><span class="comment"># 获取分类</span></span><br><span class="line">result=classify(C,group,labels,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>源码链接：</p><p><a href="https://github.com/xudapengarh/Machine-Learning/tree/master/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">https://github.com/xudapengarh/Machine-Learning/tree/master/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95</a></p><h2 id="K近邻算法——进阶"><a href="#K近邻算法——进阶" class="headerlink" title="K近邻算法——进阶"></a>K近邻算法——进阶</h2><p>当然，真正用到K近邻算法的情形并不会如上面的例子般简单，但是上例却已经能够很好的表达出K近邻算法的核心思想。接下来，我们将探讨K近邻算法更复杂的运用。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习实战-序</title>
      <link href="/2019/04/17/Machine%20Learning/machine-learning/"/>
      <url>/2019/04/17/Machine%20Learning/machine-learning/</url>
      
        <content type="html"><![CDATA[<p>机器学习实战学习记录</p><p>Github链接<a href="https://github.com/xudapengarh/Machine-Learning" target="_blank" rel="noopener">https://github.com/xudapengarh/Machine-Learning</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习实战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习实战 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建Github博客</title>
      <link href="/2019/04/07/Hexo/BuildGithubBlog/"/>
      <url>/2019/04/07/Hexo/BuildGithubBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><img src="/2019/04/07/Hexo/BuildGithubBlog/BlogHome.jpg" alt="Home"></li></ul><p>本文介绍利用Github及Hexo搭建个人免费博客。</p><a id="more"></a><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><blockquote><p>GitHub是通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。</p><p>GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开或私有的代码仓库，但付费用户支持更多功能。根据在2009年的Git用户调查，GitHub是最流行的Git访问站点。</p><p>—引自维基百科</p></blockquote><p>2018年6月4日晚上，美国科技公司微软宣布以75亿美元的股票收购GitHub，并宣布支持无限制数量的私人代码仓库。利用Github Pages，我们可以很轻松地搭建属于自己的个人博客。</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>前往Github官网：<a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a>注册属于自己的Github账户（本文以example作为示例用户名，读者在自己实践的时候将本文中所有出现example的地方替换成自己相应的名称即可）。</p><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>注册成功后登录Github，点击右上角的New repository来创建我们博客使用的代码仓库。</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/new_repository.jpg" alt="创建仓库"></p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/new_repository_1.jpg" alt="创建仓库"></p><p>注意：在填写仓库名称的时候，格式是：用户名+.github.io，如上图所示（例：假设用户名为example，那么，仓库的名称就是：example.github.io，由于本人的用户名为xudapengarh，因此，上图中的仓库名为xudapengarh.github.io，读者可根据自己的用户名进行更改）。</p><p>因为是个人博客，无需其他参与者共同维护，所以下面最好选择Private（Github被微软收购后，免费用户已经取消了以前只能创建5个私有仓库的限制，所以现在无需考虑个数限制问题）。</p><p>创建好代码仓库之后，回到个人主页，找到刚刚创建的仓库，点击进入：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/new_repository_2.jpg" alt="创建仓库"></p><p>选择Settings选项，在下面找到Pages选项：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/new_repository_3.jpg" alt="创建仓库"></p><p>当你的仓库名为：用户名.github.io 时，Github Pages是默认开启的，我们可以点击上面的链接（或<a href="https://example.github.io" target="_blank" rel="noopener">https://example.github.io</a>），进入到我们的主页中。</p><p>这时，我们的仓库就已经创建完成了。</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>—引自Hexo官网</p></blockquote><p>读者可转至Hexo官网：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a>了解更多关于Hexo的信息及用法。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><h5 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h5><p>安装Hexo需要先确保电脑上已安装有以下环境：</p><ul><li>Git</li><li>Node.js</li></ul><h5 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h5><p>前往Git官网：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a>选择相应的版本进行安装，选择默认安装即可。</p><p>安装完成后，在开始菜单中可以看到Git的工具目录：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/git_bash_1.jpg" alt="Node.js"></p><p>或者在任意文件夹下空白处点击右键，会在选项中出现Git选项：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/git_bash_2.jpg" alt="Node.js"></p><p>点击Git Bash后会出现类似于控制台一样的窗口：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/git_bash_3.jpg" alt="Node.js"></p><p>说明Git安装成功。</p><h5 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h5><p>前往Node.js官网：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">https://nodejs.org/en/download/</a>选择相应的电脑版本进行下载安装（若使用安装工具.msi安装，则需要在安装时选择将软件添加至系统环境变量中。若选择.zip进行安装，则需要手动将bin目录添加至系统Path环境变量中）。</p><h5 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h5><p>Node.js安装成功后，默认的软件源是国外的，因此在安装软件的时候速度很慢，甚至出现卡死的情况。因此，建议将Node.js的软件源切换为国内的阿里源比较好。使用命令行执行以下命令：</p><p>切换阿里源：</p><blockquote><p>npm config set registry <a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></blockquote><p>验证：</p><blockquote><p>npm config get registry</p></blockquote><p>返回<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a> ，说明镜像配置成功。</p><p>安装cnpm：</p><blockquote><p>npm install -g cnpm —registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></blockquote><p>安装Hexo：</p><p>首先，我们需要先创建安装Hexo的目录。当然，也可以在创建博客的目录中安装Hexo，不过，为了Hexo能在以后更加方便地使用，建议创建单独的Hexo安装目录（由于我已经在C:\Program Files\Hexo安装完成，因此以下图片都是在d:\test文件夹下作演示）。</p><p>首先，在C:\Program Files文件夹下创建Hexo文件夹，进入到Hexo文件夹下：右键空白处，在右键菜单中选择Git Bash Here，打开Git Bash命令行，输入：</p><blockquote><p>cnpm install hexo</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/install_hexo_1.jpg" alt="Hexo"></p><p>安装完成后，将C:\Program Files\Hexo\node_modules.bin添加至系统Path环境变量中。</p><p>输入：</p><blockquote><p>hexo -v</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/install_hexo_2.jpg" alt="Hexo"></p><p>查看Hexo版本。</p><p>至此，前期的准备工作已全部完成。</p><h2 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h2><h3 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h3><p>选择我们想要保存博客站点的文件夹，如我想在D盘下的Blog下保存我的站点信息（读者可自行选择），则使用文件管理器打开D盘，在空白处右键，在右键菜单中选择Git Bash Here，打开Git Bash命令行，输入：</p><blockquote><p>hexo init Blog</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/create_blog_1.jpg" alt="Hexo"></p><p>等待初始化完成（需要一点时间，请耐心等待）。</p><p>初始化完成后，D盘中已经出现了Blog文件夹，进入到Blog文件夹，可以看到如下目录及文件：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/blog_dictiona.jpg" alt="Hexo"></p><p>文件夹下目录及文件的作用稍后会提到，现在，我们先把我们的博客跑起来看下效果。</p><p>在Blog文件夹中空白处右键，在右键菜单中选择Git Bash Here，打开Git Bash命令行，输入：</p><blockquote><p>hexo s</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_s_1.jpg" alt="Hexo"></p><p>打开浏览器，在网址栏中输入：</p><blockquote><p><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_home_1.jpg" alt="Hexo"></p><p>若能正常打开，说明我们的博客已经成功创建。</p><p>现在，我们要做的事情就是将我们的博客部署到Github上。</p><p>打开D:\Blog下的_config.yml文件：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/config_1.jpg" alt="Hexo"></p><p>title字段的值是我们的博客标题，也可理解成我们的博客名称，可更改为自定义的值，如：</p><blockquote><p>title: 桃花源</p></blockquote><p>注意：title后的冒号必须使用英文输入法进行输入，且冒号与后面的名字之间又一个英文符的空格（以下字段值的更改同理）。</p><p>author字段的值是博客的作者名，可随意更改。</p><p>language字段的值是博客所使用的语言，若要改成中文，请进入到博客的主题目录下的languages文件夹下，查看语言文件名称后更改。</p><p>例：Hexo的默认主题是landscape，所以我们进入到D:\Blog\themes\landscape\languages文件夹：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/languages_1.jpg" alt="Hexo"></p><p>可以看到，简体中文的语言文件名称为zh-CN.yml，我们将D:\Blog下的_config.yml文件中的language字段的值改为：</p><blockquote><p>langeage: zh-CN</p></blockquote><p>更改后如下：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/config_2.jpg" alt="Hexo"></p><p>接下来，我们需要配置我们的Git信息。</p><p>打开D:\Blog下的_config.yml文件，在文件的最下面，我们可以看到：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/config_3.jpg" alt="Hexo">更改deploy下字段值如下：</p><blockquote><p>deploy:</p><p> type: git</p><p> repo: <a href="https://github.com/example/example.github.io.git" target="_blank" rel="noopener">https://github.com/example/example.github.io.git</a></p><p> branch: master</p></blockquote><p>其中repo字段中的两个example值应替换为自己的Github同户名。</p><p>保存更改后回到D:\Blog，空白处右键打开Git Bash，输入以下命令：</p><p>安装Git插件：</p><blockquote><p>cnpm install <a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> — save</p></blockquote><p>清理工程：</p><blockquote><p>hexo c</p></blockquote><p>编译工程：</p><blockquote><p>hexo g</p></blockquote><p>上传至Github:</p><blockquote><p>hexo d</p></blockquote><p>等待上传完成后（可能会弹出Github的登录窗口，在登录窗口输入用户名密码登录即可），在浏览器中打开：<a href="https://example.github.io.git，即可在浏览器中看到创建的博客了。" target="_blank" rel="noopener">https://example.github.io.git，即可在浏览器中看到创建的博客了。</a></p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_home_2.jpg" alt="Hexo"></p><h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><blockquote><p>hexo new example</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_new_1.jpg" alt="Hexo"></p><p>其中，example是文章名称，最好使用英文命名。可以看到博文文件已经成功创建在D:\Blog\source_posts下。</p><p>打开D:\Blog\source\_posts文件夹，可以看到我们的文件：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_file_1.jpg" alt="Hexo"></p><p>其中，hello-world.md文件是Hexo初始化时自动创建的一篇文章，而example.md便是刚刚创建的example文章文件了。</p><h3 id="编辑博文"><a href="#编辑博文" class="headerlink" title="编辑博文"></a>编辑博文</h3><p>Hexo是将使用Markdown语法的md文件编译成静态html，以达到可以在浏览器中访问的效果。因此，我们在编辑文章的时候，只要编辑相应的md文件，再编译即可。</p><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。读者可自行了解学习其语法，因为在日后的文章编辑中，都是直接编辑md文件，所以读者必须有一定的Markdown使用知识。</p><p>市面上有很多的Markdown编辑器，用户可自行挑选，本文中使用的Typora，用户可转至其官网安装下载：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a></p><p>安装完成后，打开example.md文件：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_file_2.jpg" alt="Hexo"></p><p>其中title字段的值是文章标题，可自行更改，注意title的冒号后面有一个英文符的空格，不可缺少。</p><p>在编辑器中输入我们的文章内容：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_file_3.jpg" alt="Hexo"></p><p>注：文章中使用了Hexo的文章截断功能：</p><blockquote><p>&lt;!—more—&gt;</p></blockquote><p>其作用是当我们访问博客首页时，该篇文章只显示&lt;!—more—&gt;处以上的内容，只有当点击文章或者点击阅读全文后，才显示全部内容。</p><p>保存编辑的文件，在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><p>清理工程：</p><blockquote><p>hexo c</p></blockquote><p>编译工程：</p><blockquote><p>hexo g</p></blockquote><p>打开本地服务：</p><blockquote><p>hexo s</p></blockquote><p>打开浏览器，在网址栏中输入：</p><blockquote><p><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></blockquote><p>即可在首页看到新建的文章：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_home_3.jpg" alt="Hexo"></p><p>可以看到，新建的文章并未全部显示在首页上，这便是文章截断功能。</p><p>点击文章标题或Read More，即可看到文章全部内容：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_home_4.jpg" alt="Hexo"></p><p>在D:\Blog文件夹下，空白处右键打开Git Bash，输入以下命令，上传至Github:</p><blockquote><p>hexo d</p></blockquote><p>等待上传完成后（可能会弹出Github的登录窗口，在登录窗口输入用户名密码登录即可），在浏览器中打开：<a href="https://example.github.io.git（example替换为自己的用户名），即可在浏览器中看到创建的博客了。" target="_blank" rel="noopener">https://example.github.io.git（example替换为自己的用户名），即可在浏览器中看到创建的博客了。</a></p><h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>Hexo提供了主题管理功能，通过更换主题，可以实现不同的主页及文章排版样式。Hexo的默认主题是landscape，下文将介绍更换Next主题的方法，读者也可以自行选择主题下载使用，使用方法大致相同。</p><h4 id="Next主题"><a href="#Next主题" class="headerlink" title="Next主题"></a>Next主题</h4><p>读者可转至Next主题官网：<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a>进行下载使用及学习更多用法。</p><h4 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h4><p>主题的下载可以通过Git命令下载，也可以通过浏览器下载，为了更直观地展示，本文将通过第二种方法进行下载。</p><p>转至<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a></p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_1.jpg" alt="Hexo"></p><p>点击右边的Clone or download按钮，选择Download ZIP</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_2.jpg" alt="Hexo"></p><p>下载完成后将压缩包中的hexo-theme-next-master文件夹整个解压到D:\Blog\themes目录下：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_3.jpg" alt="Hexo"></p><p>重命名hexo-theme-next-master文件夹为next：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_4.jpg" alt="Hexo"></p><p>打开站点目录（D:\Blog）下的_config.yml文件，找到theme字段：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_5.jpg" alt="Hexo"></p><p>将theme字段的值改为next（注意冒号后的英文空格）</p><blockquote><p>theme: next</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_6.jpg" alt="Hexo"></p><p>找到language字段，更改为D:\Blog\themes\next\languages下的中文文件名：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_8.jpg" alt="Hexo"></p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_9.jpg" alt="Hexo"></p><p>保存编辑的文件，在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><p>清理工程：</p><blockquote><p>hexo c</p></blockquote><p>编译工程：</p><blockquote><p>hexo g</p></blockquote><p>打开本地服务：</p><blockquote><p>hexo s</p></blockquote><p>打开浏览器，在网址栏中输入：</p><blockquote><p><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/next_7.jpg" alt="Hexo"></p><p>可以看到，博客主页已经与之前不同。</p><h3 id="创建带有图片的文章"><a href="#创建带有图片的文章" class="headerlink" title="创建带有图片的文章"></a>创建带有图片的文章</h3><p>打开站点目录（D:\Blog）下的_config.yml文件，找到post_asset_folder字段：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_config_1.jpg" alt="Hexo"></p><p>将字段值更改为True（注意冒号后的英文空格）</p><blockquote><p>post_asset_folder: true</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_config_2.jpg" alt="Hexo"></p><p>保存更改。</p><p>在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><blockquote><p>cnpm install hexo-asset-image --save</p></blockquote><p>新建文章：</p><blockquote><p>hexo new image</p></blockquote><p>打开D:\Blog\source\_posts：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_3.jpg" alt="Hexo"></p><p>可以看到，在D:\Blog\source\_posts文件夹下，有一个image.md文件以及image文件夹（以后每次创建新的文章的时候，都会与一个同名文件夹）。</p><p>将要插入文章的图片文件放入到image文件夹下：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_4.jpg" alt="Hexo"></p><p>打开D:\Blog\source\_posts文件夹下的image.md文件，输入以下内容：</p><blockquote><p>![图片](image/image.jpg)</p></blockquote><p>其中，方括号里的内容是在图片未能正确加载时的提示（可随意更改），括号里是图片的路径（可根据不同文章名与图片名进行更改）。</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_5.jpg" alt="Hexo"></p><p>可以看到，Typora已经提供了实时的预览。</p><p>保存编辑，在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><p>清理工程：</p><blockquote><p>hexo c</p></blockquote><p>编译工程：</p><blockquote><p>hexo g</p></blockquote><p>打开本地服务：</p><blockquote><p>hexo s</p></blockquote><p>打开浏览器，在网址栏中输入：</p><blockquote><p><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_6.jpg" alt="Hexo"></p><p>本地预览效果如上。</p><p>将文章更新至Github：</p><p>在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><blockquote><p>hexo d</p></blockquote><p>等待上传完成后（可能会弹出Github的登录窗口，在登录窗口输入用户名密码登录即可），在浏览器中打开：<a href="https://example.github.io.git（example替换为自己的用户名），即可在浏览器中看到创建的博客了。" target="_blank" rel="noopener">https://example.github.io.git（example替换为自己的用户名），即可在浏览器中看到创建的博客了。</a></p><h3 id="添加分类、归档、标签"><a href="#添加分类、归档、标签" class="headerlink" title="添加分类、归档、标签"></a>添加分类、归档、标签</h3><h4 id="添加分类"><a href="#添加分类" class="headerlink" title="添加分类"></a>添加分类</h4><p>在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><blockquote><p>hexo new page categories</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_10.jpg" alt="Hexo"></p><p>打开D:\Blog\source\categories文件夹：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_11.jpg" alt="Hexo"></p><p>删除index文件夹（创建标签、归档时也将相应目录下index文件夹删除）。</p><p>编辑index.md文件如下（注意冒号后有英文符的空格）：</p><blockquote><p>title: 分类</p><p>type: “categories”</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_12.jpg" alt="Hexo"></p><p>保存编辑。</p><h4 id="添加归档"><a href="#添加归档" class="headerlink" title="添加归档"></a>添加归档</h4><p>在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><blockquote><p>hexo new page archives</p></blockquote><p>打开D:\Blog\source\archives文件夹，更改index.md文件如下（注意冒号后有英文符的空格）：</p><blockquote><p>title: 归档</p><p>type: “archives”</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_14.jpg" alt="Hexo"></p><h4 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h4><p>在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><blockquote><p>hexo new page tags</p></blockquote><p>打开D:\Blog\source\tags文件夹，更改index.md文件如下（注意冒号后有英文符的空格）：</p><blockquote><p>title: 标签</p><p>type: “tags”</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_15.jpg" alt="Hexo"></p><p>打开主题目录（D:\Blog\themes\next）下的_config.yml文件，找到menu字段下的内容：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_16.jpg" alt="Hexo"></p><p>去掉tags、categories、archives字段前的注释：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_17.jpg" alt="Hexo"></p><p>保存修改，在D:\Blog下空白处右键打开Git Bash，输入以下命令：</p><p>清理工程：</p><blockquote><p>hexo c</p></blockquote><p>编译工程：</p><blockquote><p>hexo g</p></blockquote><p>打开本地服务：</p><blockquote><p>hexo s</p></blockquote><p>打开浏览器，在网址栏中输入：</p><blockquote><p><a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a></p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_18.jpg" alt="Hexo"></p><p>打开D:\Blog\scaffolds下的post.md文件：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_20.jpg" alt="Hexo"></p><p>修改为：</p><blockquote><p>title: Hexo搭建Github博客<br>date: 1554607143000<br>categories:<br>archives:<br>tags:</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_21.jpg" alt="Hexo"></p><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>创建一篇新文章以查看效果：</p><blockquote><p>hexo new test</p></blockquote><p>注意冒号后的英文符空格</p><blockquote><p>title: 测试<br>date: 2019-04-07 22:33:09<br>categories: 分类测试<br>archives: 归档测试<br>tags: 标签测试</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_23.jpg" alt="Hexo"></p><p>清理、编译并打开本地服务，查看效果：</p><p>主页：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_26.jpg" alt="Hexo"></p><p>标签：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_27.jpg" alt="Hexo"></p><p>分类：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_28.jpg" alt="Hexo"></p><p>归档：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_29.jpg" alt="Hexo"></p><h4 id="去除底部信息"><a href="#去除底部信息" class="headerlink" title="去除底部信息"></a>去除底部信息</h4><p>在博客底部，附有Hexo以及Next主题的相关信息：</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_31.jpg" alt="Hexo"></p><p>下文提供去除这些信息的方法。</p><p>打开D:\Blog\themes\next下的_config.yml文件，找到copyright字段:</p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_32.jpg" alt="Hexo"></p><p>修改以下的值（注意冒号后的英文符空格）</p><blockquote><p>powered: false</p><p> theme:</p><p>​    # Theme &amp; scheme info link (Theme - NexT.scheme).</p><p>​    enable: false</p><p>​    # Version info of NexT after scheme info (vX.X.X).</p><p>​    version: true</p></blockquote><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_33.jpg" alt="Hexo"></p><p>保存修改并清理、编译工程。</p><p>打开本地服务，在浏览器中访问<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p><img src="/2019/04/07/Hexo/BuildGithubBlog/hexo_34.jpg" alt="Hexo"></p><p>可以看到，底部信息已经去除掉了。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>更多Hexo以及Next用法请访问官网进行研究。</p><p>Hexo：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a></p><p>Next：<a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">http://theme-next.iissnan.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪念博客搭建成功</title>
      <link href="/2019/04/07/Hexo/FirstPage/"/>
      <url>/2019/04/07/Hexo/FirstPage/</url>
      
        <content type="html"><![CDATA[<h3 id="纪念博客搭建成功"><a href="#纪念博客搭建成功" class="headerlink" title="纪念博客搭建成功"></a>纪念博客搭建成功</h3><p align="right">--2019.6.7 by 许大鹏</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
